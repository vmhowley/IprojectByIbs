import { Ticket } from '../types';
import { handleSupabaseResponse, supabase } from './api';
import { notificationService } from './notificationService';

export const ticketService = {
  async getByProject(projectId: string): Promise<Ticket[]> {
    return handleSupabaseResponse(
      supabase
        .from('tickets')
        .select('*')
        .eq('project_id', projectId)
        .order('created_at', { ascending: false })
    );
  },

  async getAll(): Promise<Ticket[]> {
    return handleSupabaseResponse(
      supabase
        .from('tickets')
        .select('*, projects(name), clients(name)')
        .order('created_at', { ascending: false })
    );
  },

  async getById(id: string): Promise<Ticket> {
    return handleSupabaseResponse(
      supabase
        .from('tickets')
        .select('*')
        .eq('id', id)
        .maybeSingle()
    );
  },



  async create(ticket: Omit<Partial<Ticket>, 'subtasks'> & { subtasks?: string[] }): Promise<Ticket> {
    // Get current user ID from session
    const { data: { user } } = await supabase.auth.getUser();
    
    // Extract subtasks to avoid sending them to the tickets table
    const { subtasks, ...ticketData } = ticket;

    const newTicket = await handleSupabaseResponse<Ticket>(
      supabase
        .from('tickets')
        .insert({
          ...ticketData,
          created_by: user?.id,
        })
        .select()
        .single()
    );

    if (subtasks && subtasks.length > 0) {
      const { subtaskService } = await import('./subtaskService');
      await Promise.all(subtasks.map(title => 
        subtaskService.create({
          ticket_id: newTicket.id,
          title
        })
      ));
    }

    // Notification Logic: If assigned to someone else
    if (newTicket.assigned_to && newTicket.assigned_to !== user?.id) {
        // We might want to fetch the ticket number properly if it's generated by DB trigger (it usually returns it in the select())
        notificationService.create(
            newTicket.assigned_to,
            'Nueva Tarea Asignada',
            `Te han asignado la tarea #${newTicket.ticket_number || 'Nueva'}: ${newTicket.subject || 'Sin asunto'}`,
            'assignment',
            `/ticket/${newTicket.id}`
        );
    }

    return newTicket;
  },


  async update(id: string, updates: Partial<Ticket>): Promise<Ticket> {
    const updatedTicket = await handleSupabaseResponse<Ticket>(
      supabase
        .from('tickets')
        .update(updates)
        .eq('id', id)
        .select()
        .single()
    );

    // Notification Logic: If assignee changed
    if (updates.assigned_to) {
         const { data: { user } } = await supabase.auth.getUser();
         if (updates.assigned_to !== user?.id) {
             notificationService.create(
                updates.assigned_to,
                'Tarea Asignada',
                `Te han asignado la tarea #${updatedTicket.ticket_number}: ${updatedTicket.subject || 'Sin asunto'}`,
                'assignment',
                `/ticket/${updatedTicket.id}`
            );
         }
    }

    return updatedTicket;
  },

  async updateStatus(id: string, status: Ticket['status']): Promise<Ticket> {
    return this.update(id, { status });
  },

  async delete(id: string): Promise<void> {
    const { error } = await supabase
      .from('tickets')
      .delete()
      .eq('id', id);

    if (error) throw error;
  }
};
